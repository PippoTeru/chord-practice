<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Practice App</title>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Arial', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #333;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
}

.container {
    background: white;
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.1);
    width: 95%;
    max-width: 1400px;
    text-align: center;
}

h1 {
    color: #4a5568;
    margin-bottom: 30px;
    font-size: 2.5em;
    font-weight: 300;
}

h2 {
    color: #4a5568;
    margin-bottom: 20px;
    font-size: 2em;
    font-weight: 400;
}

.game-status {
    display: flex;
    justify-content: space-around;
    margin-bottom: 30px;
    padding: 20px;
    background: #f7fafc;
    border-radius: 10px;
}

.status-item {
    display: flex;
    align-items: center;
    gap: 10px;
}

.label {
    font-weight: bold;
    color: #4a5568;
}

.timer {
    font-size: 2em;
    font-weight: bold;
    color: #e53e3e;
    min-width: 60px;
}

.score {
    font-size: 2em;
    font-weight: bold;
    color: #38a169;
    min-width: 40px;
}

.unit {
    color: #718096;
}


.controls {
    display: flex;
    justify-content: center;
    gap: 20px;
}

.btn {
    padding: 15px 30px;
    font-size: 1.2em;
    font-weight: bold;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 150px;
}

.start-btn {
    background: linear-gradient(135deg, #48bb78, #38a169);
    color: white;
}

.start-btn:hover {
    background: linear-gradient(135deg, #38a169, #2f855a);
    transform: translateY(-2px);
}

.restart-btn {
    background: linear-gradient(135deg, #4299e1, #3182ce);
    color: white;
}

.restart-btn:hover {
    background: linear-gradient(135deg, #3182ce, #2c5282);
    transform: translateY(-2px);
}



.midi-device-selection {
    margin-bottom: 20px;
    padding: 15px;
    background: #f7fafc;
    border-radius: 10px;
    display: flex;
    align-items: center;
    gap: 15px;
    justify-content: center;
}

.device-label {
    font-weight: bold;
    color: #4a5568;
}

.device-select {
    padding: 8px 12px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    background: white;
    color: #4a5568;
    font-size: 1em;
    min-width: 250px;
}

.device-select:focus {
    outline: none;
    border-color: #4299e1;
}

.piano-display {
    margin: 20px 0;
    padding: 0;
    background: transparent;
}

.piano-keyboard {
    position: relative;
    background: transparent;
    width: 100%;
    margin: 0;
    overflow-x: visible;
    display: flex;
    justify-content: center;
}

.piano-key {
    position: absolute;
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    font-weight: bold;
    transition: all 0.1s ease;
    border-radius: 0 0 5px 5px;
}

.piano-key.white {
    background: white;
    border: 1px solid #ddd;
    z-index: 1;
    color: #666;
    padding-bottom: 3px;
}

.piano-key.black {
    background: #1a1a1a;
    border: 1px solid #000;
    z-index: 2;
    color: #ccc;
    padding-bottom: 2px;
    border-radius: 0 0 3px 3px;
}

.piano-key.pressed {
    background: #4299e1 !important;
    color: white !important;
    transform: scale(0.95);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
}

.piano-key.white.left-hand-range.pressed,
.piano-key.white.right-hand-range.pressed {
    background: #4299e1 !important;
    color: white !important;
}

.piano-key.correct {
    background: #48bb78 !important;
    color: white !important;
}

.piano-key.incorrect {
    background: #f56565 !important;
    color: white !important;
}

.piano-key.white.left-hand-range {
    background: rgba(66, 153, 225, 0.3) !important;
}

.piano-key.white.right-hand-range {
    background: rgba(72, 187, 120, 0.3) !important;
}

.screen {
    display: block;
}

.title-header {
    text-align: center;
    margin-bottom: 60px;
}

.music-icon {
    font-size: 4em;
    margin-bottom: 20px;
    animation: bounce 2s ease-in-out infinite;
}

@keyframes bounce {
    0%, 20%, 50%, 80%, 100% {
        transform: translateY(0);
    }
    40% {
        transform: translateY(-10px);
    }
    60% {
        transform: translateY(-5px);
    }
}

.main-title {
    font-size: 3.5em;
    font-weight: bold;
    margin-bottom: 10px;
    color: #4a5568; /* fallback color */
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: none;
}

/* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
@media (max-width: 768px) {
    .main-title {
        font-size: 2.8em;
    }
    
    .music-icon {
        font-size: 3em;
    }
    
    .title-btn {
        width: 240px;
        font-size: 1.2em;
        padding: 18px 25px;
    }
    
    .subtitle {
        font-size: 1.1em;
    }
}

.subtitle {
    font-size: 1.2em;
    color: #718096;
    margin: 0;
    font-weight: normal;
}

.title-controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 40px 0;
}

.title-btn {
    width: 280px;
    padding: 20px 30px;
    font-size: 1.3em;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

.title-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
}

.btn-icon {
    font-size: 1.2em;
}

.title-footer {
    margin-top: 40px;
    text-align: center;
}

.description {
    color: #718096;
    font-size: 1em;
    margin: 0;
    font-style: italic;
}

.version-info {
    color: #a0aec0;
    font-size: 0.8em;
    margin: 8px 0 0 0;
    font-family: 'Courier New', monospace;
    opacity: 0.7;
}

.secondary-btn {
    background: linear-gradient(135deg, #718096, #4a5568);
    color: white;
}

.secondary-btn:hover {
    background: linear-gradient(135deg, #4a5568, #2d3748);
    transform: translateY(-2px);
}

.settings-header {
    text-align: center;
    margin-bottom: 40px;
}

.settings-icon {
    font-size: 3em;
    margin-bottom: 15px;
}

.settings-title {
    font-size: 2.2em;
    font-weight: bold;
    margin-bottom: 8px;
    color: #4a5568;
}

.settings-subtitle {
    font-size: 1.1em;
    color: #718096;
    margin: 0;
}

.settings-content {
    display: flex;
    flex-direction: column;
    gap: 30px;
    margin-bottom: 40px;
}

.midi-section, .audio-section, .instructions-section {
    background: #f8fafc;
    border-radius: 15px;
    padding: 25px;
    border: 1px solid #e2e8f0;
}

.section-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 20px;
}

.section-icon {
    font-size: 1.5em;
}

.section-title {
    font-size: 1.3em;
    font-weight: bold;
    color: #4a5568;
    margin: 0;
}

.midi-status {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 15px 20px;
    border-radius: 10px;
    margin-bottom: 20px;
    background: #fed7d7;
    border: 1px solid #feb2b2;
}

.midi-status.connected {
    background: #c6f6d5;
    border: 1px solid #9ae6b4;
}

.status-icon {
    font-size: 1.2em;
}

.status-content {
    flex: 1;
    font-weight: 500;
    color: #2d3748;
}

.device-label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: bold;
    color: #4a5568;
    margin-bottom: 10px;
    font-size: 1em;
}

.label-icon {
    font-size: 1.1em;
}

.device-select-wrapper {
    position: relative;
    display: inline-block;
    width: 100%;
}

.device-select {
    width: 100%;
    padding: 12px 40px 12px 15px;
    border: 2px solid #e2e8f0;
    border-radius: 10px;
    background: white;
    color: #4a5568;
    font-size: 1em;
    appearance: none;
    cursor: pointer;
    transition: all 0.3s ease;
}

.device-select:focus {
    outline: none;
    border-color: #4299e1;
    box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
}

.select-arrow {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    color: #718096;
    pointer-events: none;
    font-size: 0.8em;
}

.instructions-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.instruction-item {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 12px 0;
}

.step-number {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 30px;
    height: 30px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 50%;
    font-weight: bold;
    font-size: 0.9em;
}

.step-text {
    color: #4a5568;
    font-size: 1em;
}

.audio-controls {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.volume-control {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.volume-label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: bold;
    color: #4a5568;
    font-size: 1em;
}

.volume-slider-wrapper {
    display: flex;
    align-items: center;
    gap: 15px;
}

.volume-slider {
    flex: 1;
    height: 6px;
    border-radius: 3px;
    background: #e2e8f0;
    outline: none;
    -webkit-appearance: none;
}

.volume-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.volume-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.volume-value {
    min-width: 40px;
    font-weight: bold;
    color: #4a5568;
    font-size: 0.9em;
}

.sustain-pedal-indicator {
    background: white;
    border-radius: 10px;
    padding: 15px;
    border: 1px solid #e2e8f0;
}

.pedal-status {
    display: flex;
    align-items: center;
    gap: 10px;
}

.pedal-icon {
    font-size: 1.2em;
}

.pedal-label {
    font-weight: bold;
    color: #4a5568;
}

.pedal-state {
    padding: 4px 8px;
    border-radius: 4px;
    font-weight: bold;
    font-size: 0.8em;
    min-width: 40px;
    text-align: center;
}

.pedal-state.off {
    background: #fed7d7;
    color: #c53030;
}

.pedal-state.on {
    background: #c6f6d5;
    color: #2d7d32;
}

.audio-info {
    background: white;
    border-radius: 10px;
    padding: 15px;
    border: 1px solid #e2e8f0;
}

.info-item {
    display: flex;
    align-items: center;
    gap: 10px;
}

.info-icon {
    font-size: 1.1em;
}

.info-text {
    color: #4a5568;
    font-size: 0.9em;
    line-height: 1.4;
}

.settings-controls {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 30px;
}

/* ã‚²ãƒ¼ãƒ ç”»é¢ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.game-header {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 2px solid #e2e8f0;
}

.game-icon {
    font-size: 2em;
}

.game-title {
    font-size: 1.8em;
    font-weight: bold;
    margin: 0;
    color: #4a5568;
}

.difficulty-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9em;
    color: #718096;
    margin-left: auto;
}

.difficulty-label {
    font-weight: 500;
}

.difficulty-value {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 4px 12px;
    border-radius: 15px;
    font-weight: bold;
    font-size: 0.85em;
}

.game-status-container {
    margin-bottom: 30px;
}

.game-status {
    display: flex;
    justify-content: space-between;
    gap: 20px;
    margin-bottom: 25px;
    padding: 0;
    background: transparent;
    border-radius: 0;
}

.status-card {
    background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
    border-radius: 12px;
    padding: 15px 20px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    border: 1px solid #e2e8f0;
    display: flex;
    align-items: center;
    gap: 12px;
    flex: 1;
    max-width: 200px;
}

.timer-card {
    border-left: 4px solid #e53e3e;
}

.score-card {
    border-left: 4px solid #38a169;
}

.card-icon {
    font-size: 1.8em;
}

.card-content {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.card-label {
    font-size: 0.9em;
    font-weight: 500;
    color: #718096;
}

.card-value {
    display: flex;
    align-items: baseline;
    gap: 5px;
}

.timer {
    font-size: 1.8em;
    font-weight: bold;
    color: #e53e3e;
}

.score {
    font-size: 1.8em;
    font-weight: bold;
    color: #38a169;
}

.unit {
    font-size: 0.9em;
    color: #718096;
    font-weight: normal;
}

.chord-section {
    background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
    border-radius: 20px;
    padding: 25px;
    margin-bottom: 25px;
    border: 1px solid #e2e8f0;
    box-shadow: 0 4px 20px rgba(0,0,0,0.05);
}

.chord-header {
    text-align: center;
    margin-bottom: 25px;
}

.chord-instruction {
    font-size: 1.2em;
    color: #4a5568;
    margin: 0;
    font-weight: 500;
}

.chord-display {
    text-align: center;
    padding: 35px 20px;
    background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
    border-radius: 15px;
    border: 2px solid #e2e8f0;
    margin-bottom: 25px;
    transition: all 0.3s ease;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.02);
    position: relative;
}

.correct-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 150px;
    height: 150px;
    background: transparent;
    border: 8px solid #e53e3e;
    border-radius: 50%;
    animation: correctPulse 0.6s ease-out;
    box-shadow: 0 4px 20px rgba(229, 62, 62, 0.4);
    z-index: 15;
}

@keyframes correctPulse {
    0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
    }
    50% {
        transform: translate(-50%, -50%) scale(1.15);
        opacity: 1;
    }
    100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
    }
}

.countdown-display {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 120px;
    height: 120px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    z-index: 10;
}

.countdown-display span {
    font-size: 4em;
    font-weight: bold;
    color: white;
    animation: countdownPulse 1s ease-in-out;
}

@keyframes countdownPulse {
    0% {
        transform: scale(0);
        opacity: 0;
    }
    50% {
        transform: scale(1.2);
        opacity: 1;
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

.result-display {
    text-align: center;
    padding: 30px 20px;
    background: linear-gradient(135deg, #f0fff4 0%, #e6fffa 100%);
    border-radius: 15px;
    border: 2px solid #38a169;
    margin-bottom: 25px;
    box-shadow: 0 4px 15px rgba(56, 161, 105, 0.15);
}

.result-display .result-icon {
    font-size: 2.5em;
    margin-bottom: 15px;
}

.result-display .result-title {
    font-size: 1.5em;
    font-weight: bold;
    color: #2d3748;
    margin-bottom: 20px;
}

.result-display .final-score-display {
    margin-bottom: 15px;
}

.result-display .score-label {
    font-size: 1em;
    color: #4a5568;
    margin-bottom: 8px;
}

.result-display .score-number {
    display: flex;
    align-items: baseline;
    justify-content: center;
    gap: 8px;
}

.result-display .score-number span:first-child {
    font-size: 2.5em;
    font-weight: bold;
    color: #38a169;
}

.result-display .score-unit {
    font-size: 1.2em;
    color: #4a5568;
}

.result-display .result-message {
    color: #4a5568;
    font-size: 1.1em;
}

#current-chord {
    font-size: 4em;
    font-weight: bold;
    color: #2d3748;
}

.chord-info {
    margin-bottom: 15px;
}

.hand-info {
    display: flex;
    justify-content: center;
    gap: 20px;
    flex-wrap: wrap;
}

.hand-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    border-radius: 12px;
    background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
    border: 2px solid #e2e8f0;
    box-shadow: 0 3px 8px rgba(0,0,0,0.08);
    font-size: 1em;
    font-weight: 600;
    transition: all 0.2s ease;
    min-width: 160px;
}

.hand-item:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.12);
}

.left-hand {
    border: 2px solid #3182ce;
    background: linear-gradient(135deg, #ebf8ff 0%, #bee3f8 100%);
    color: #2c5282;
}

.left-hand .hand-icon {
    background: #3182ce;
    color: white;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2em;
}

.right-hand {
    border: 2px solid #38a169;
    background: linear-gradient(135deg, #f0fff4 0%, #c6f6d5 100%);
    color: #276749;
}

.right-hand .hand-icon {
    background: #38a169;
    color: white;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2em;
}


.hand-text {
    font-weight: 600;
    flex: 1;
}

.game-controls {
    display: flex;
    justify-content: center;
    gap: 15px;
    flex-wrap: wrap;
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid #e2e8f0;
}

.game-btn {
    min-width: 140px;
    padding: 15px 25px;
    font-size: 1.1em;
}

.result-area {
    background: transparent;
    padding: 0;
    border-radius: 0;
    margin-bottom: 30px;
}

.result-card {
    background: white;
    border-radius: 20px;
    padding: 40px 30px;
    text-align: center;
    box-shadow: 0 8px 30px rgba(0,0,0,0.1);
    border: 1px solid #e2e8f0;
}

.result-icon {
    font-size: 3em;
    margin-bottom: 15px;
}

.result-title {
    font-size: 2em;
    font-weight: bold;
    color: #4a5568;
    margin-bottom: 25px;
}

.final-score-display {
    margin-bottom: 20px;
}

.score-label {
    font-size: 1.1em;
    color: #718096;
    margin-bottom: 10px;
}

.score-number {
    display: flex;
    align-items: baseline;
    justify-content: center;
    gap: 8px;
}

.score-number #final-score {
    font-size: 3em;
    font-weight: bold;
    color: #38a169;
}

.score-unit {
    font-size: 1.2em;
    color: #718096;
}

.result-message {
    color: #4a5568;
    font-size: 1.1em;
}

.piano-display {
    background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
    border-radius: 20px;
    padding: 25px;
    border: 1px solid #e2e8f0;
    box-shadow: 0 4px 20px rgba(0,0,0,0.05);
}

@media (max-width: 768px) {
    .settings-content {
        gap: 20px;
    }
    
    .midi-section, .instructions-section {
        padding: 20px;
    }
    
    .settings-controls {
        flex-direction: column;
        align-items: center;
    }
    
    .settings-controls .btn {
        width: 240px;
    }
    
    .game-status {
        flex-direction: column;
        align-items: center;
    }
    
    .status-card {
        width: 100%;
        max-width: 280px;
    }
    
    .hand-info {
        flex-direction: column;
        gap: 15px;
    }
    
    .hand-item {
        justify-content: center;
    }
    
    .game-controls {
        flex-direction: column;
        align-items: center;
    }
    
    .game-btn {
        width: 200px;
    }
    
    #current-chord {
        font-size: 3em;
    }
}

@keyframes correct {
    0% { background: #c6f6d5; }
    100% { background: #f7fafc; }
}

@keyframes incorrect {
    0% { background: #fed7d7; }
    100% { background: #f7fafc; }
}

.chord-display.correct {
    animation: correct 0.5s ease;
}

.chord-display.incorrect {
    animation: incorrect 0.5s ease;
}
    </style>
</head>
<body>
    <div class="container">
        <!-- ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ -->
        <div id="title-screen" class="screen">
            <div class="title-header">
                <div class="music-icon">ğŸ¹</div>
                <h1 class="main-title">Chord Master</h1>
                <p class="subtitle">ãƒ”ã‚¢ãƒã‚³ãƒ¼ãƒ‰ç·´ç¿’ã‚¢ãƒ—ãƒª</p>
            </div>
            <div class="title-controls">
                <button id="game-start-btn" class="btn title-btn start-btn">
                    <span class="btn-icon">ğŸµ</span>
                    <span>ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</span>
                </button>
                <button id="settings-btn" class="btn title-btn secondary-btn">
                    <span class="btn-icon">âš™ï¸</span>
                    <span>ç’°å¢ƒè¨­å®š</span>
                </button>
            </div>
            <div class="title-footer">
                <p class="description">MIDIã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã§ã‚³ãƒ¼ãƒ‰ã‚’æ¼”å¥ã—ã¦ç·´ç¿’ã—ã‚ˆã†</p>
                <p class="version-info" id="version-info">v0.1.0</p>
            </div>
        </div>

        <!-- ç’°å¢ƒè¨­å®šç”»é¢ -->
        <div id="settings-screen" class="screen" style="display: none;">
            <div class="settings-header">
                <div class="settings-icon">âš™ï¸</div>
                <h2 class="settings-title">ç’°å¢ƒè¨­å®š</h2>
                <p class="settings-subtitle">MIDIã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®æ¥ç¶šè¨­å®š</p>
            </div>

            <div class="settings-content">
                <div class="midi-section">
                    <div class="section-header">
                        <div class="section-icon">ğŸ¹</div>
                        <h3 class="section-title">MIDIãƒ‡ãƒã‚¤ã‚¹</h3>
                    </div>
                    
                    <div id="midi-status" class="midi-status">
                        <div class="status-icon">
                            <span id="status-indicator">ğŸ”´</span>
                        </div>
                        <div class="status-content">
                            <span id="midi-message">MIDIãƒ‡ãƒã‚¤ã‚¹ã‚’æ¥ç¶šã—ã¦ãã ã•ã„</span>
                        </div>
                    </div>

                    <div id="midi-device-selection" class="midi-device-selection" style="display: none;">
                        <label for="midi-devices" class="device-label">
                            <span class="label-icon">ğŸ¼</span>
                            MIDIãƒ‡ãƒã‚¤ã‚¹é¸æŠ
                        </label>
                        <div class="device-select-wrapper">
                            <select id="midi-devices" class="device-select">
                                <option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„</option>
                            </select>
                            <div class="select-arrow">â–¼</div>
                        </div>
                    </div>
                </div>

                <div class="audio-section">
                    <div class="section-header">
                        <div class="section-icon">ğŸ”Š</div>
                        <h3 class="section-title">ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¨­å®š</h3>
                    </div>
                    
                    <div class="audio-controls">
                        <div class="volume-control">
                            <label for="volume-slider" class="volume-label">
                                <span class="label-icon">ğŸšï¸</span>
                                ãƒ”ã‚¢ãƒéŸ³é‡
                            </label>
                            <div class="volume-slider-wrapper">
                                <input type="range" id="volume-slider" class="volume-slider" 
                                       min="0" max="100" value="100" step="1">
                                <span id="volume-value" class="volume-value">100%</span>
                            </div>
                        </div>
                        <div class="sustain-pedal-indicator">
                            <div class="pedal-status" id="sustain-pedal-status">
                                <span class="pedal-icon">ğŸ¦¶</span>
                                <span class="pedal-label">ã‚µã‚¹ãƒ†ã‚£ãƒ¼ãƒ³ãƒšãƒ€ãƒ«</span>
                                <span class="pedal-state" id="pedal-state">OFF</span>
                            </div>
                        </div>
                        <div class="audio-info">
                            <div class="info-item">
                                <span class="info-icon">â„¹ï¸</span>
                                <span class="info-text">MIDIã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®æ¼”å¥ã«åˆã‚ã›ã¦ãƒ”ã‚¢ãƒéŸ³ãŒå†ç”Ÿã•ã‚Œã¾ã™</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="instructions-section">
                    <div class="section-header">
                        <div class="section-icon">ğŸ’¡</div>
                        <h3 class="section-title">ä½¿ã„æ–¹</h3>
                    </div>
                    <div class="instructions-content">
                        <div class="instruction-item">
                            <span class="step-number">1</span>
                            <span class="step-text">MIDIã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚’ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã«æ¥ç¶š</span>
                        </div>
                        <div class="instruction-item">
                            <span class="step-number">2</span>
                            <span class="step-text">ä¸Šè¨˜ã§ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ</span>
                        </div>
                        <div class="instruction-item">
                            <span class="step-number">3</span>
                            <span class="step-text">ã€Œã‚²ãƒ¼ãƒ ç”»é¢ã¸ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-controls">
                <button id="back-to-title-btn" class="btn secondary-btn">
                    <span class="btn-icon">ğŸ </span>
                    <span>ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</span>
                </button>
                <button id="go-to-game-btn" class="btn start-btn" style="display: none;">
                    <span class="btn-icon">ğŸ®</span>
                    <span>ã‚²ãƒ¼ãƒ ç”»é¢ã¸</span>
                </button>
            </div>
        </div>

        <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
        <div id="game-screen" class="screen" style="display: none;">
            <div id="game-area" class="game-area">
                <div class="chord-section">
                    <div class="game-header">
                        <div class="game-icon">ğŸµ</div>
                        <h2 class="game-title">ã‚³ãƒ¼ãƒ‰ç·´ç¿’</h2>
                        <div class="difficulty-indicator">
                            <span class="difficulty-label">ãƒ¬ãƒ™ãƒ«:</span>
                            <span class="difficulty-value">åˆç´š - ãƒˆãƒ©ã‚¤ã‚¢ãƒ‰</span>
                        </div>
                    </div>
                    <div id="game-status" class="game-status">
                        <div class="status-card timer-card">
                            <div class="card-icon">â°</div>
                            <div class="card-content">
                                <div class="card-label">æ®‹ã‚Šæ™‚é–“</div>
                                <div class="card-value">
                                    <span id="timer" class="timer">60</span>
                                    <span class="unit">ç§’</span>
                                </div>
                            </div>
                        </div>
                        <div class="status-card score-card">
                            <div class="card-icon">ğŸ¯</div>
                            <div class="card-content">
                                <div class="card-label">ã‚¹ã‚³ã‚¢</div>
                                <div class="card-value">
                                    <span id="score" class="score">0</span>
                                    <span class="unit">å•æ­£è§£</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="chord-header">
                        <h3 class="chord-instruction" style="display: none;">ã“ã®å’ŒéŸ³ã‚’æ¼”å¥ã—ã¦ãã ã•ã„</h3>
                        <div id="velocity-debug" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 12px; display: none;">
                            ãƒ™ãƒ­ã‚·ãƒ†ã‚£ãƒ¬ã‚¤ãƒ¤ãƒ¼: <span id="velocity-layer-display">-</span>
                        </div>
                    </div>
                    <div id="chord-display" class="chord-display">
                        <span id="current-chord">ã‚¹ã‚¿ãƒ¼ãƒˆã‚’æŠ¼ã—ã¦ãã ã•ã„</span>
                        <div id="correct-indicator" class="correct-indicator" style="display: none;"></div>
                        <div id="countdown-display" class="countdown-display" style="display: none;">
                            <span id="countdown-number">3</span>
                        </div>
                    </div>
                    <div id="result-display" class="result-display" style="display: none;">
                        <div class="result-icon">ğŸ‰</div>
                        <h3 class="result-title">ã‚²ãƒ¼ãƒ çµ‚äº†ï¼</h3>
                        <div class="final-score-display">
                            <div class="score-label">æœ€çµ‚ã‚¹ã‚³ã‚¢</div>
                            <div class="score-number">
                                <span id="final-score-inline">0</span>
                                <span class="score-unit">å•æ­£è§£</span>
                            </div>
                        </div>
                        <div class="result-message">
                            <span id="result-message-inline">ãŠç–²ã‚Œã•ã¾ã§ã—ãŸï¼</span>
                        </div>
                    </div>
                    <div class="game-controls">
                        <button id="start-btn" class="btn game-btn start-btn">
                            <span class="btn-icon">â–¶ï¸</span>
                            <span>ã‚¹ã‚¿ãƒ¼ãƒˆ</span>
                        </button>
                        <button id="restart-btn" class="btn game-btn restart-btn" style="display: none;">
                            <span class="btn-icon">ğŸ”„</span>
                            <span>ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</span>
                        </button>
                        <button id="back-to-title-from-game-btn" class="btn game-btn secondary-btn">
                            <span class="btn-icon">ğŸ </span>
                            <span>ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</span>
                        </button>
                    </div>
                </div>
            </div>

            <div id="result-area" class="result-area" style="display: none;">
                <div class="result-card">
                    <div class="result-icon">ğŸ‰</div>
                    <h2 class="result-title">ã‚²ãƒ¼ãƒ çµ‚äº†ï¼</h2>
                    <div class="final-score-display">
                        <div class="score-label">æœ€çµ‚ã‚¹ã‚³ã‚¢</div>
                        <div class="score-number">
                            <span id="final-score">0</span>
                            <span class="score-unit">å•æ­£è§£</span>
                        </div>
                    </div>
                    <div class="result-message">
                        <span id="result-message">ãŠç–²ã‚Œã•ã¾ã§ã—ãŸï¼</span>
                    </div>
                </div>
            </div>

            <div id="piano-display" class="piano-display">
                <div class="chord-info">
                    <div class="hand-info">
                        <div class="hand-item left-hand">
                            <span class="hand-icon">ğŸ‘ˆ</span>
                            <span class="hand-text">å·¦æ‰‹: ãƒ«ãƒ¼ãƒˆéŸ³</span>
                        </div>
                        <div class="hand-item right-hand">
                            <span class="hand-icon">ğŸ‘‰</span>
                            <span class="hand-text">å³æ‰‹: ã‚³ãƒ¼ãƒ‰æ§‹æˆéŸ³</span>
                        </div>
                    </div>
                </div>
                <div class="piano-keyboard" id="piano-keyboard">
                    <!-- ãƒ”ã‚¢ãƒéµç›¤ãŒã“ã“ã«ç”Ÿæˆã•ã‚Œã¾ã™ -->
                </div>
            </div>
        </div>
    </div>

    <!-- ãƒ­ãƒ¼ãƒ‰ç”»é¢ -->
    <div id="loading-screen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); z-index: 9999; display: none; flex-direction: column; align-items: center; justify-content: center; color: white;">
        <div style="text-align: center; max-width: 600px; padding: 40px;">
            <h1 style="font-size: 3em; margin-bottom: 20px; font-weight: 300;">ã‚³ãƒ¼ãƒ‰ç·´ç¿’ã‚¢ãƒ—ãƒª</h1>
            <div style="margin-bottom: 40px;">
                <div id="loading-message" style="font-size: 1.2em; margin-bottom: 20px;">ãƒ”ã‚¢ãƒã‚µãƒ³ãƒ—ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
                <div id="loading-progress-container" style="background: rgba(255,255,255,0.2); border-radius: 10px; padding: 10px; margin-bottom: 20px;">
                    <div id="loading-progress-bar" style="height: 20px; background: linear-gradient(90deg, #4CAF50, #8BC34A); border-radius: 10px; width: 0%; transition: width 0.3s ease;"></div>
                </div>
                <div id="loading-details" style="font-size: 0.9em; opacity: 0.8;">0 / 480 ãƒ•ã‚¡ã‚¤ãƒ« (0%)</div>
            </div>
            <div style="font-size: 0.9em; opacity: 0.7; line-height: 1.5;">
                ã™ã¹ã¦ã®ãƒ™ãƒ­ã‚·ãƒ†ã‚£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’èª­ã¿è¾¼ã‚“ã§ã€æœ€é«˜ã®éŸ³è³ªã¨å¿œç­”æ€§ã‚’å®Ÿç¾ã—ã¾ã™ã€‚<br>
                åˆå›èª­ã¿è¾¼ã¿ã«ã¯æ•°åˆ†ã‹ã‹ã‚Šã¾ã™ãŒã€ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚
            </div>
        </div>
    </div>

    <script>
class ChordPracticeApp {
    // ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ï¼ˆãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã«æœ€å¾Œã®æ¡ã‚’å¢—åŠ : 0.1.0 -> 0.1.1 -> 0.1.2...ï¼‰
    showVelocityDebug(velocityLayer, velocity, volume) {
        if (this.elements.velocityDebug && this.elements.velocityLayerDisplay) {
            this.elements.velocityDebug.style.display = 'block';
            this.elements.velocityLayerDisplay.textContent = `${velocityLayer}/16 (vel:${velocity}, vol:${(volume*100).toFixed(0)}%)`;
            
            // 3ç§’å¾Œã«è‡ªå‹•ã§éè¡¨ç¤º
            clearTimeout(this.velocityDebugTimeout);
            this.velocityDebugTimeout = setTimeout(() => {
                if (this.elements.velocityDebug) {
                    this.elements.velocityDebug.style.display = 'none';
                }
            }, 3000);
        }
    }
    
    async initializeApp() {
        try {
            // åŸºæœ¬çš„ãªåˆæœŸåŒ–ã®ã¿å®Ÿè¡Œï¼ˆã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚µãƒ³ãƒ—ãƒ«ã®èª­ã¿è¾¼ã¿ã¯é™¤ãï¼‰
            await this.initializeBasics();
            
        } catch (error) {
            console.error('Initialization failed:', error);
            alert('åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚');
        }
    }
    
    async initializeBasics() {
        // ãƒ­ãƒ¼ãƒ‰ç”»é¢ã‚’éè¡¨ç¤ºã«ã™ã‚‹
        this.hideLoadingScreen();
        
        // MIDIã®ã¿åˆæœŸåŒ–
        await this.setupMIDI();
        
        // ãƒ”ã‚¢ãƒéµç›¤ã‚’ä½œæˆ
        this.createPianoKeyboard();
        
        // è¨­å®šã‚’é©ç”¨
        this.applySettings();
    }
    
    async initializeAudioForGame() {
        try {
            // ãƒ­ãƒ¼ãƒ‰ç”»é¢ã‚’è¡¨ç¤º
            this.showLoadingScreen();
            
            // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨ã‚µãƒ³ãƒ—ãƒ«ã‚’åˆæœŸåŒ–
            await this.initializeAudio();
            
            // ãƒ­ãƒ¼ãƒ‰å®Œäº†å¾Œã«ãƒ­ãƒ¼ãƒ‰ç”»é¢ã‚’éè¡¨ç¤º
            this.hideLoadingScreen();
            
            return true;
        } catch (error) {
            console.error('Audio initialization failed:', error);
            this.hideLoadingScreen();
            alert('ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
            return false;
        }
    }
    
    showLoadingScreen() {
        if (this.elements.loadingScreen) {
            this.elements.loadingScreen.style.display = 'flex';
        }
    }
    
    hideLoadingScreen() {
        if (this.elements.loadingScreen) {
            this.elements.loadingScreen.style.display = 'none';
        }
    }
    
    updateLoadingProgress(loaded, total, currentFile = '') {
        const percentage = Math.round((loaded / total) * 100);
        
        if (this.elements.loadingProgressBar) {
            this.elements.loadingProgressBar.style.width = `${percentage}%`;
        }
        
        if (this.elements.loadingDetails) {
            this.elements.loadingDetails.textContent = `${loaded} / ${total} ãƒ•ã‚¡ã‚¤ãƒ« (${percentage}%)`;
        }
        
        if (currentFile && this.elements.loadingMessage) {
            this.elements.loadingMessage.textContent = `èª­ã¿è¾¼ã¿ä¸­: ${currentFile}`;
        }
    }
    
    async loadSingleSample(midiNote, velocityLayer) {
        try {
            const fileName = this.getMIDIFileName(midiNote, velocityLayer);
            const response = await fetch(`mp3/${fileName}`);
            
            if (response.ok) {
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                
                // æ–°ã—ã„ã‚­ãƒ¼å½¢å¼ã§ä¿å­˜
                const velocityKey = `${midiNote}_v${velocityLayer.toString().padStart(2, '0')}`;
                this.audioBuffers.set(velocityKey, audioBuffer);
                
                // ãƒ™ãƒ­ã‚·ãƒ†ã‚£ãƒ¬ã‚¤ãƒ¤ãƒ¼8ã¯å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚å¤ã„ã‚­ãƒ¼ã§ã‚‚ä¿å­˜
                if (velocityLayer === 8) {
                    this.audioBuffers.set(midiNote, audioBuffer);
                }
                
                return { success: true, fileName, midiNote, velocityLayer };
            } else {
                console.warn(`Failed to load ${fileName}`);
                return { success: false, fileName, error: `HTTP ${response.status}` };
            }
        } catch (error) {
            return { success: false, error: error.message };
        }
    }
    
    static VERSION = '0.1.40';
    
    constructor() {
        this.chords = [
            { name: 'C', notes: [0, 4, 7] },      // C major
            { name: 'Dm', notes: [2, 5, 9] },     // D minor
            { name: 'Em', notes: [4, 7, 11] },    // E minor
            { name: 'F', notes: [5, 9, 0] },      // F major
            { name: 'G', notes: [7, 11, 2] },     // G major
            { name: 'Am', notes: [9, 0, 4] },     // A minor
            { name: 'Bdim', notes: [11, 2, 5] }   // B diminished
        ];
        
        this.currentChord = null;
        this.gameActive = false;
        this.timeLeft = 60;
        this.score = 0;
        this.timer = null;
        this.pressedKeys = new Set();
        this.currentRange = null;
        this.justAnswered = false;
        
        this.midiAccess = null;
        this.midiInput = null;
        this.pianoKeys = {};
        this.resizeTimeout = null;
        
        // ã‚µã‚¹ãƒ†ã‚£ãƒ¼ãƒ³ãƒšãƒ€ãƒ«é–¢é€£
        this.sustainPedalPressed = false;
        this.sustainedNotes = new Set(); // ã‚µã‚¹ãƒ†ã‚£ãƒ¼ãƒ³ãƒšãƒ€ãƒ«ã§ç¶­æŒã•ã‚Œã‚‹éŸ³ç¨‹
        
        // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³çŠ¶æ…‹ç®¡ç†
        this.countdownInterval = null;
        
        // æ­£è§£å¾Œã®å¾…æ©ŸçŠ¶æ…‹ç®¡ç†
        this.waitingForNextQuestion = false;
        
        // MIDIãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’åˆæœŸåŒ–æ™‚ã«ãƒã‚¤ãƒ³ãƒ‰
        this.midiMessageHandler = this.onMIDIMessage.bind(this);
        
        // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨éŸ³æºã®åˆæœŸåŒ–
        this.audioContext = null;
        this.audioBuffers = new Map(); // ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒƒãƒ•ã‚¡
        this.activeSources = new Map(); // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªéŸ³æº
        this.masterVolume = null;
        // è¨­å®šã®åˆæœŸåŒ–ã¨èª­ã¿è¾¼ã¿
        this.settings = this.loadSettings();
        
        this.initializeElements();
        this.setupEventListeners();
        
        // éåŒæœŸã§åˆæœŸåŒ–ã‚’å®Ÿè¡Œ
        this.initializeApp();
    }
    
    initializeElements() {
        this.elements = {
            timer: document.getElementById('timer'),
            score: document.getElementById('score'),
            currentChord: document.getElementById('current-chord'),
            correctIndicator: document.getElementById('correct-indicator'),
            countdownDisplay: document.getElementById('countdown-display'),
            countdownNumber: document.getElementById('countdown-number'),
            startBtn: document.getElementById('start-btn'),
            restartBtn: document.getElementById('restart-btn'),
            gameArea: document.getElementById('game-area'),
            resultArea: document.getElementById('result-area'),
            finalScore: document.getElementById('final-score'),
            resultDisplay: document.getElementById('result-display'),
            finalScoreInline: document.getElementById('final-score-inline'),
            resultMessageInline: document.getElementById('result-message-inline'),
            midiMessage: document.getElementById('midi-message'),
            midiStatus: document.getElementById('midi-status'),
            chordDisplay: document.getElementById('chord-display'),
            midiDeviceSelection: document.getElementById('midi-device-selection'),
            midiDevicesSelect: document.getElementById('midi-devices'),
            pianoKeyboard: document.getElementById('piano-keyboard'),
            titleScreen: document.getElementById('title-screen'),
            settingsScreen: document.getElementById('settings-screen'),
            gameScreen: document.getElementById('game-screen'),
            gameStartBtn: document.getElementById('game-start-btn'),
            settingsBtn: document.getElementById('settings-btn'),
            backToTitleBtn: document.getElementById('back-to-title-btn'),
            backToTitleFromGameBtn: document.getElementById('back-to-title-from-game-btn'),
            goToGameBtn: document.getElementById('go-to-game-btn'),
            statusIndicator: document.getElementById('status-indicator'),
            volumeSlider: document.getElementById('volume-slider'),
            volumeValue: document.getElementById('volume-value'),
            pedalState: document.getElementById('pedal-state'),
            versionInfo: document.getElementById('version-info'),
            chordInstruction: document.querySelector('.chord-instruction'),
            velocityDebug: document.getElementById('velocity-debug'),
            velocityLayerDisplay: document.getElementById('velocity-layer-display'),
            loadingScreen: document.getElementById('loading-screen'),
            loadingMessage: document.getElementById('loading-message'),
            loadingProgressBar: document.getElementById('loading-progress-bar'),
            loadingDetails: document.getElementById('loading-details')
        };
    }
    
    async initializeAudio() {
        try {
            // AudioContextã‚’ä½œæˆï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œã«åˆæœŸåŒ–ï¼‰
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // ãƒªãƒŸãƒƒã‚¿ãƒ¼ã¨ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼ã‚’ä½œæˆ
            this.createLimiter();
            
            // ãƒã‚¹ã‚¿ãƒ¼ãƒœãƒªãƒ¥ãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
            this.masterVolume = this.audioContext.createGain();
            this.masterVolume.gain.setValueAtTime((this.settings.volume / 100) * 3, this.audioContext.currentTime);
            this.masterVolume.connect(this.compressor);
            
            console.log('Audio context initialized with limiter');
            
            // WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ï¼ˆãƒ­ãƒ¼ãƒ‰ç”»é¢ã§é€²è¡ŒçŠ¶æ³ã‚’è¡¨ç¤ºï¼‰
            await this.preloadAudioFiles();
            
        } catch (error) {
            console.error('Failed to initialize audio context:', error);
            throw error;
        }
    }
    
    createLimiter() {
        // -0.5dBã§ãƒªãƒŸãƒƒã‚¿ãƒ¼ã‚’ä½œæˆ
        const limitThreshold = Math.pow(10, -0.5 / 20); // -0.5dB = ç´„0.944ã®æŒ¯å¹…
        
        // ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼ã§ã‚½ãƒ•ãƒˆãƒªãƒŸãƒƒãƒ†ã‚£ãƒ³ã‚°
        this.compressor = this.audioContext.createDynamicsCompressor();
        this.compressor.threshold.setValueAtTime(-3, this.audioContext.currentTime); // -3dB threshold
        this.compressor.knee.setValueAtTime(0, this.audioContext.currentTime); // Hard knee
        this.compressor.ratio.setValueAtTime(20, this.audioContext.currentTime); // High ratio for limiting
        this.compressor.attack.setValueAtTime(0.001, this.audioContext.currentTime); // Fast attack
        this.compressor.release.setValueAtTime(0.1, this.audioContext.currentTime); // Quick release
        
        // ãƒãƒ¼ãƒ‰ãƒªãƒŸãƒƒã‚¿ãƒ¼ï¼ˆWaveShaperï¼‰
        this.limiter = this.audioContext.createWaveShaper();
        this.limiter.curve = this.createLimiterCurve(limitThreshold);
        this.limiter.oversample = '4x';
        
        // ãƒªãƒãƒ¼ãƒ–ã‚’ä½œæˆ
        this.createReverb();
        
        // æ¥ç¶š: compressor -> reverb -> limiter -> destination
        this.compressor.connect(this.reverbSend);
        this.compressor.connect(this.limiter); // ãƒ‰ãƒ©ã‚¤ã‚·ã‚°ãƒŠãƒ«
        this.reverbReturn.connect(this.limiter); // ã‚¦ã‚§ãƒƒãƒˆã‚·ã‚°ãƒŠãƒ«
        this.limiter.connect(this.audioContext.destination);
        
        console.log(`Audio chain created: compressor -> reverb -> limiter -> destination`);
        console.log(`Limiter threshold: ${limitThreshold.toFixed(3)} (-0.5dB)`);
    }
    
    createLimiterCurve(threshold) {
        // WaveShaperç”¨ã®ã‚«ãƒ¼ãƒ–ã‚’ä½œæˆ
        const samples = 65536;
        const curve = new Float32Array(samples);
        
        for (let i = 0; i < samples; i++) {
            const x = (i * 2) / samples - 1; // -1 to 1ã®ç¯„å›²
            const absX = Math.abs(x);
            
            if (absX <= threshold) {
                // ã—ãã„å€¤ä»¥ä¸‹ã¯ãã®ã¾ã¾
                curve[i] = x;
            } else {
                // ã—ãã„å€¤ä»¥ä¸Šã¯ãƒãƒ¼ãƒ‰ãƒªãƒŸãƒƒãƒˆ
                curve[i] = Math.sign(x) * threshold;
            }
        }
        
        return curve;
    }
    
    createReverb() {
        // ã‚³ãƒ³ãƒœãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ãƒªãƒãƒ¼ãƒ–ç”¨ã®ã‚¤ãƒ³ãƒ‘ãƒ«ã‚¹ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ä½œæˆ
        const sampleRate = this.audioContext.sampleRate;
        const length = sampleRate * 2.0; // 2ç§’ã®ãƒªãƒãƒ¼ãƒ–
        const impulse = this.audioContext.createBuffer(2, length, sampleRate);
        
        // ãƒ«ãƒ¼ãƒ ãƒªãƒãƒ¼ãƒ–ã®ã‚¤ãƒ³ãƒ‘ãƒ«ã‚¹ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ç”Ÿæˆ
        for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
                const n = length - i;
                // æŒ‡æ•°é–¢æ•°çš„ã«æ¸›è¡°ã™ã‚‹ãƒã‚¤ã‚ºï¼ˆãƒ«ãƒ¼ãƒ ç‰¹æ€§ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼‰
                const decay = Math.pow(n / length, 2.5); // æ¸›è¡°ã‚«ãƒ¼ãƒ–
                const earlyReflection = i < sampleRate * 0.05 ? Math.random() * 0.3 : 0; // åˆæœŸåå°„
                const lateReverb = (Math.random() * 2 - 1) * decay * 0.15; // å¾ŒæœŸæ®‹éŸ¿
                channelData[i] = (earlyReflection + lateReverb) * (1 - channel * 0.1); // ã‚¹ãƒ†ãƒ¬ã‚ªå·®
            }
        }
        
        // ã‚³ãƒ³ãƒœãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ãƒªãƒãƒ¼ãƒ–ã‚’ä½œæˆ
        this.reverb = this.audioContext.createConvolver();
        this.reverb.buffer = impulse;
        
        // ãƒªãƒãƒ¼ãƒ–ã‚»ãƒ³ãƒ‰ï¼ˆã‚¦ã‚§ãƒƒãƒˆä¿¡å·ç”¨ï¼‰
        this.reverbSend = this.audioContext.createGain();
        this.reverbSend.gain.setValueAtTime(0.12, this.audioContext.currentTime); // 12%ã®æ§ãˆã‚ãªãƒªãƒãƒ¼ãƒ–
        
        // ãƒªãƒãƒ¼ãƒ–ãƒªã‚¿ãƒ¼ãƒ³
        this.reverbReturn = this.audioContext.createGain();
        this.reverbReturn.gain.setValueAtTime(1.0, this.audioContext.currentTime);
        
        // æ¥ç¶š: reverbSend -> reverb -> reverbReturn
        this.reverbSend.connect(this.reverb);
        this.reverb.connect(this.reverbReturn);
        
        console.log('Room reverb created (2.0s decay, 12% wet)');
    }
    
    async preloadAudioFiles() {
        // ä¸»è¦ãªéŸ³åŸŸã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å®šç¾©ï¼ˆ3åŠéŸ³ã”ã¨ã«ã‚µãƒ³ãƒ—ãƒ«ï¼‰
        const sampleNotes = [
            21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99, 102, 105, 108
        ];
        
        console.log('Starting to preload piano samples...');
        
        // ä¸¦åˆ—èª­ã¿è¾¼ã¿ã§é«˜é€ŸåŒ–ï¼ˆã™ã¹ã¦ã®ãƒ™ãƒ­ã‚·ãƒ†ã‚£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ï¼‰
        const allLayers = Array.from({length: 16}, (_, i) => i + 1); // 1-16ã®ã™ã¹ã¦ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼
        let loadedCount = 0;
        let totalFiles = sampleNotes.length * allLayers.length;
        
        console.log(`Preloading ${totalFiles} velocity layer samples with parallel loading...`);
        
        // ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸¦åˆ—ã§èª­ã¿è¾¼ã¿
        const loadPromises = [];
        
        for (const midiNote of sampleNotes) {
            for (const velocityLayer of allLayers) {
                const loadPromise = this.loadSingleSample(midiNote, velocityLayer)
                    .then((result) => {
                        if (result.success) {
                            loadedCount++;
                            
                            // é€²è¡ŒçŠ¶æ³ã‚’æ›´æ–°ï¼ˆã‚¹ãƒ­ãƒƒãƒˆãƒ«ã—ã¦ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’ä¿ã¤ï¼‰
                            if (loadedCount % 10 === 0 || loadedCount === totalFiles) {
                                this.updateLoadingProgress(loadedCount, totalFiles, result.fileName);
                            }
                            
                            if (loadedCount % 100 === 0) {
                                console.log(`Loaded ${loadedCount}/${totalFiles} samples (${((loadedCount/totalFiles)*100).toFixed(1)}%)`);
                            }
                        }
                        return result;
                    })
                    .catch((error) => {
                        console.warn(`Error loading sample for note ${midiNote}, layer ${velocityLayer}:`, error);
                        return { success: false, error };
                    });
                
                loadPromises.push(loadPromise);
            }
        }
        
        // ã™ã¹ã¦ã®èª­ã¿è¾¼ã¿ã‚’ä¸¦åˆ—å®Ÿè¡Œï¼ˆåŒæ™‚æ¥ç¶šæ•°ã‚’åˆ¶é™ã—ã¦ãƒ–ãƒ©ã‚¦ã‚¶ã‚’ä¿è­·ï¼‰
        const batchSize = 20; // 20ãƒ•ã‚¡ã‚¤ãƒ«ãšã¤ä¸¦åˆ—èª­ã¿è¾¼ã¿
        for (let i = 0; i < loadPromises.length; i += batchSize) {
            const batch = loadPromises.slice(i, i + batchSize);
            await Promise.all(batch);
            // ãƒãƒƒãƒé–“ã§å°‘ã—å¾…æ©Ÿã—ã¦ãƒ–ãƒ©ã‚¦ã‚¶ã‚’ä¼‘ã¾ã›ã‚‹
            if (i + batchSize < loadPromises.length) {
                await new Promise(resolve => setTimeout(resolve, 10));
            }
        }
        
        console.log(`Parallel preloading complete: ${loadedCount}/${totalFiles} samples loaded`);
        
        // æœ€çµ‚é€²è¡ŒçŠ¶æ³ã‚’æ›´æ–°
        this.updateLoadingProgress(loadedCount, totalFiles, 'å®Œäº†!');
        
        console.log(`Preloaded ${this.audioBuffers.size} piano samples`);
    }
    
    async loadSingleAudioFile(filePath) {
        try {
            const response = await fetch(filePath);
            if (response.ok) {
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                this.audioBuffers.set(filePath, audioBuffer);
                console.log(`Loaded audio file: ${filePath}`);
            } else {
                console.warn(`Failed to load ${filePath}`);
            }
        } catch (error) {
            console.warn(`Error loading audio file ${filePath}:`, error);
            throw error;
        }
    }
    
    getMIDIFileName(midiNote, velocity = 8) {
        // MIDIãƒãƒ¼ãƒˆç•ªå·ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const octave = Math.floor(midiNote / 12) - 1;
        const noteName = noteNames[midiNote % 12];
        const velocityStr = velocity.toString().padStart(2, '0');
        
        // #æ–‡å­—ã‚’URLã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã¦æ­£ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
        const encodedNoteName = encodeURIComponent(noteName);
        return `${midiNote.toString().padStart(3, '0')}_${encodedNoteName}${octave}v${velocityStr}.mp3`;
    }
    
    findClosestSample(midiNote) {
        // æœ€ã‚‚è¿‘ã„ã‚µãƒ³ãƒ—ãƒ«ã‚’æ¢ã™
        let closestNote = null;
        let minDistance = Infinity;
        
        for (const note of this.audioBuffers.keys()) {
            const distance = Math.abs(note - midiNote);
            if (distance < minDistance) {
                minDistance = distance;
                closestNote = note;
            }
        }
        
        return closestNote;
    }
    
    // MIDIãƒãƒ¼ãƒˆç•ªå·ã‚’å‘¨æ³¢æ•°ã«å¤‰æ›
    midiToFrequency(midiNote) {
        return 440 * Math.pow(2, (midiNote - 69) / 12);
    }
    
    // ãƒ™ãƒ­ã‚·ãƒ†ã‚£ã‹ã‚‰é©åˆ‡ãªãƒ¬ã‚¤ãƒ¤ãƒ¼ç•ªå·ã‚’è¨ˆç®—ï¼ˆç›´ç·šçš„ãƒãƒƒãƒ”ãƒ³ã‚°ï¼‰
    getVelocityLayer(velocity) {
        // 0-115ã®ãƒ™ãƒ­ã‚·ãƒ†ã‚£ã‚’1-16ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ç›´ç·šçš„ã«ãƒãƒƒãƒ”ãƒ³ã‚°
        const clampedVel = Math.min(115, velocity); // 115ã§ä¸Šé™åˆ¶é™
        const normalizedVel = clampedVel / 115; // 0-1ã«æ­£è¦åŒ–
        const layer = Math.floor(normalizedVel * 15) + 1; // 1-16ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼
        return Math.max(1, Math.min(16, layer));
    }
    
    // WAVã‚µãƒ³ãƒ—ãƒ«ã§ãƒ”ã‚¢ãƒéŸ³ã‚’å†ç”Ÿ
    playNote(midiNote, velocity = 127) {
        if (!this.audioContext) return;
        
        // AudioContextãŒåœæ­¢çŠ¶æ…‹ã®å ´åˆã€å†é–‹
        if (this.audioContext.state === 'suspended') {
            this.audioContext.resume();
        }
        
        // æ—¢å­˜ã®éŸ³ã‚’åœæ­¢
        this.stopNote(midiNote);
        
        // ãƒ™ãƒ­ã‚·ãƒ†ã‚£ã‹ã‚‰é©åˆ‡ãªãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¨ˆç®—
        const velocityLayer = this.getVelocityLayer(velocity);
        
        // é©åˆ‡ãªã‚µãƒ³ãƒ—ãƒ«ã‚’æ¢ã™
        const closestSample = this.findClosestSample(midiNote);
        if (closestSample) {
            // æŒ‡å®šã•ã‚ŒãŸãƒ™ãƒ­ã‚·ãƒ†ã‚£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’æ¢ã™
            const velocityKey = `${closestSample}_v${velocityLayer.toString().padStart(2, '0')}`;
            let audioBuffer = this.audioBuffers.get(velocityKey);
            
            // æŒ‡å®šãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ã‚µãƒ³ãƒ—ãƒ«ï¼ˆv08ï¼‰ã‚’ä½¿ç”¨
            if (!audioBuffer) {
                audioBuffer = this.audioBuffers.get(closestSample);
                console.warn(`Velocity layer ${velocityLayer} not found for note ${closestSample}, using default layer 8`);
            }
            
            if (audioBuffer) {
                this.playWAVSample(midiNote, velocity, closestSample, audioBuffer, audioBuffer === this.audioBuffers.get(closestSample) ? 8 : velocityLayer);
                
                // ã™ã¹ã¦ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ã®ãŸã‚ã€èƒŒæ™¯ãƒ­ãƒ¼ãƒ‰ã¯ä¸è¦
                return;
            }
        }
        
        // WAVã‚µãƒ³ãƒ—ãƒ«ãŒåˆ©ç”¨ã§ããªã„å ´åˆã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯éŸ³æºã‚’ä½¿ç”¨
        console.log(`No WAV sample available for note ${midiNote}, using fallback tone`);
        this.playFallbackTone(midiNote, velocity);
    }
    
    // èƒŒæ™¯ã§ãƒ™ãƒ­ã‚·ãƒ†ã‚£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ï¼ˆéåŒæœŸï¼‰
    preloadVelocityLayerInBackground(midiNote, velocityLayer) {
        const velocityKey = `${midiNote}_v${velocityLayer.toString().padStart(2, '0')}`;
        if (this.audioBuffers.has(velocityKey)) {
            return; // æ—¢ã«ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿
        }
        
        const fileName = this.getMIDIFileName(midiNote, velocityLayer);
        this.loadVelocityLayer(midiNote, velocityLayer, fileName).catch(error => {
            console.warn(`Background preload failed for velocity layer ${velocityLayer}:`, error);
        });
    }
    
    async loadVelocityLayer(midiNote, velocityLayer, fileName) {
        try {
            const response = await fetch(`mp3/${fileName}`);
            if (response.ok) {
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                const velocityKey = `${midiNote}_v${velocityLayer.toString().padStart(2, '0')}`;
                this.audioBuffers.set(velocityKey, audioBuffer);
                console.log(`Loaded velocity layer ${velocityLayer} for note ${midiNote}: ${fileName}`);
            } else {
                throw new Error(`HTTP ${response.status}`);
            }
        } catch (error) {
            console.warn(`Error loading velocity layer: ${error}`);
            throw error;
        }
    }
    
    playWAVSample(midiNote, velocity, closestSample, audioBuffer, velocityLayer = 8) {
        const now = this.audioContext.currentTime;
        
        // AudioBufferSourceNodeã‚’ä½œæˆ
        const source = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();
        
        source.buffer = audioBuffer;
        
        // ãƒ”ãƒƒãƒã‚·ãƒ•ãƒˆï¼ˆå†ç”Ÿãƒ¬ãƒ¼ãƒˆã§èª¿æ•´ï¼‰
        const semitoneShift = midiNote - closestSample;
        const playbackRate = Math.pow(2, semitoneShift / 12);
        source.playbackRate.setValueAtTime(playbackRate, now);
        
        // ãƒ™ãƒ­ã‚·ãƒ†ã‚£ã«åŸºã¥ãéŸ³é‡èª¿æ•´ï¼ˆãƒ€ãƒ–ãƒ«ãƒ€ã‚¤ãƒŠãƒŸã‚¯ã‚¹ï¼‰
        // ãƒ™ãƒ­ã‚·ãƒ†ã‚£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨éŸ³é‡ã®ä¸¡æ–¹ã§ãƒ€ã‚¤ãƒŠãƒŸã‚¯ã‚¹ã‚’è¡¨ç¾
        const normalizedVel = velocity / 127;
        const volume = 0.06 + (normalizedVel * 0.34); // æœ€å°6%ã‹ã‚‰æœ€å¤§40%ã¾ã§ï¼ˆ300%ãƒã‚¹ã‚¿ãƒ¼ã§æœ€å°18%ã€æœ€å¤§120%ï¼‰
        gainNode.gain.setValueAtTime(volume, now);
        
        // æ¥ç¶š
        source.connect(gainNode);
        gainNode.connect(this.masterVolume);
        
        // å†ç”Ÿé–‹å§‹
        source.start(now);
        
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚½ãƒ¼ã‚¹ã¨ã—ã¦ä¿å­˜
        this.activeSources.set(midiNote, { source, gainNode });
        
        // ãƒ™ãƒ­ã‚·ãƒ†ã‚£ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã‚’è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
        this.showVelocityDebug(velocityLayer, velocity, volume);
        
        console.log(`Playing piano note ${midiNote} using velocity layer ${velocityLayer} (vel:${velocity}/127, vol:${(volume*100).toFixed(0)}%) sample ${closestSample}`);
    }
    
    playFallbackTone(midiNote, velocity) {
        const frequency = this.midiToFrequency(midiNote);
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯éŸ³æºã§ã‚‚0-127ã®ç¯„å›²ã§ãƒ€ã‚¤ãƒŠãƒŸã‚¯ã‚¹ã‚’é©ç”¨
        const normalizedVel = velocity / 127;
        const volume = (0.03 + (normalizedVel * 0.17)) * 0.2; // 0.006-0.04ã®ç¯„å›²ï¼ˆè»½ã„ã‚¿ãƒƒãƒã‚’ã•ã‚‰ã«å°ã•ãï¼‰
        const now = this.audioContext.currentTime;
        
        // ã‚·ãƒ³ãƒ—ãƒ«ãªã‚µã‚¤ãƒ³æ³¢ã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(frequency, now);
        
        // ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(volume * 0.3, now + 0.1);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
        
        oscillator.connect(gainNode);
        gainNode.connect(this.masterVolume);
        
        oscillator.start(now);
        oscillator.stop(now + 1.0);
        
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚½ãƒ¼ã‚¹ã¨ã—ã¦ä¿å­˜
        this.activeSources.set(midiNote, { source: oscillator, gainNode });
        
        console.log(`Playing fallback tone for note ${midiNote} (${frequency.toFixed(2)}Hz)`);
    }
    
    // WAVã‚µãƒ³ãƒ—ãƒ«ãƒ”ã‚¢ãƒéŸ³ã‚’åœæ­¢
    stopNote(midiNote) {
        const sourceData = this.activeSources.get(midiNote);
        if (sourceData) {
            const { source, gainNode } = sourceData;
            const now = this.audioContext.currentTime;
            
            try {
                // ã‚ˆã‚ŠçŸ­ã„æ¸›è¡°æ™‚é–“ã§è‡ªç„¶ãªãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                gainNode.gain.cancelScheduledValues(now);
                gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3); // 0.3ç§’ã§ãƒ•ã‚§ãƒ¼ãƒ‰
                
                // ãƒªãƒãƒ¼ãƒ–ãƒ†ãƒ¼ãƒ«ã‚’è€ƒæ…®ã—ã¦é…å»¶åœæ­¢
                source.stop(now + 0.5);
            } catch (error) {
                // æ—¢ã«åœæ­¢ã—ã¦ã„ã‚‹å ´åˆã®ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–
                console.warn(`Error stopping note ${midiNote}:`, error);
            }
            
            // ãƒãƒƒãƒ—ã‹ã‚‰å‰Šé™¤
            this.activeSources.delete(midiNote);
            
            console.log(`Stopping piano note ${midiNote} with natural decay`);
        }
    }
    
    createPianoKeyboard() {
        console.log('Creating piano keyboard...');
        const keyboard = this.elements.pianoKeyboard;
        if (!keyboard) {
            console.error('Piano keyboard element not found!');
            return;
        }
        
        keyboard.innerHTML = '';
        this.pianoKeys = {};
        
        // 88éµç›¤è¡¨ç¤º (A0-C8)
        const startNote = 21; // A0
        const endNote = 108;  // C8
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        // éµç›¤ã‚µã‚¤ã‚ºã®è¨ˆç®—
        const container = document.querySelector('.container');
        const containerStyles = window.getComputedStyle(container);
        const containerPadding = parseFloat(containerStyles.paddingLeft) + parseFloat(containerStyles.paddingRight);
        const availableWidth = container.offsetWidth - containerPadding;
        const totalWhiteKeys = 52; // 88éµãƒ”ã‚¢ãƒã®ç™½éµæ•°
        
        // æœ€å°éµç›¤å¹…ã¨ç†æƒ³éµç›¤å¹…ã‚’è¨­å®š
        const minWhiteKeyWidth = 8; // æœ€å°å¹…ã‚’å°ã•ãã—ã¦ã€ã‚ˆã‚Šç‹­ã„ç”»é¢ã§ã‚‚ç¸®å°ã§ãã‚‹ã‚ˆã†ã«
        const idealWhiteKeyWidth = Math.floor(availableWidth / totalWhiteKeys);
        const whiteKeyWidth = Math.max(minWhiteKeyWidth, idealWhiteKeyWidth);
        const blackKeyWidth = Math.floor(whiteKeyWidth * 0.6);
        
        // ç¸¦æ¨ªæ¯”ã‚’ä¿ã£ã¦é«˜ã•ã‚’è¨ˆç®—ï¼ˆç™½éµã®å¹…:é«˜ã• = 1:6ã®æ¯”ç‡ã€å®Ÿéš›ã®ãƒ”ã‚¢ãƒã«è¿‘ã„ï¼‰
        const whiteKeyHeight = Math.floor(whiteKeyWidth * 6);
        const blackKeyHeight = Math.floor(whiteKeyHeight * 0.6);
        
        console.log(`Debug: availableWidth=${availableWidth}, idealWhiteKeyWidth=${idealWhiteKeyWidth}, whiteKeyWidth=${whiteKeyWidth}`);
        
        // ãƒ–ãƒ©ã‚¦ã‚¶ã®å¹…ã‚’å¤‰ãˆãŸæ™‚ã®ãƒ†ã‚¹ãƒˆç”¨
        if (whiteKeyWidth <= 8) {
            console.log(`âš ï¸ Using minimum width: ${whiteKeyWidth}px (screen too narrow)`);
        } else {
            console.log(`âœ… Using calculated width: ${whiteKeyWidth}px (screen wide enough)`);
        }
        
        // å„ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ã§ã®ç™½éµã®é…ç½®ãƒ‘ã‚¿ãƒ¼ãƒ³
        const whiteKeyPattern = [0, 2, 4, 5, 7, 9, 11]; // C, D, E, F, G, A, B
        const blackKeyPattern = [1, 3, 6, 8, 10]; // C#, D#, F#, G#, A#
        
        // éµç›¤å…¨ä½“ã®å¹…ã¨é«˜ã•ã‚’è¨ˆç®—
        const totalKeyboardWidth = 52 * whiteKeyWidth;
        const keyboardContainer = document.createElement('div');
        keyboardContainer.style.position = 'relative';
        keyboardContainer.style.width = totalKeyboardWidth + 'px';
        keyboardContainer.style.height = whiteKeyHeight + 'px';
        
        // è¦ªã‚³ãƒ³ãƒ†ãƒŠã®é«˜ã•ã‚‚å‹•çš„ã«è¨­å®š
        keyboard.style.height = whiteKeyHeight + 'px';
        
        keyboard.appendChild(keyboardContainer);
        
        // ç™½éµã‚’é…ç½®
        let whiteKeyCount = 0;
        for (let note = startNote; note <= endNote; note++) {
            const noteIndex = note % 12;
            
            if (whiteKeyPattern.includes(noteIndex)) {
                const key = document.createElement('div');
                key.className = 'piano-key white';
                key.dataset.note = note;
                
                const noteName = noteNames[noteIndex];
                const octave = Math.floor(note / 12) - 1;
                key.textContent = `${noteName}${octave}`;
                
                // ç™½éµã®ä½ç½®ã¨ã‚µã‚¤ã‚ºã‚’è¨­å®š
                key.style.left = (whiteKeyCount * whiteKeyWidth) + 'px';
                key.style.top = '0px';
                key.style.width = whiteKeyWidth + 'px';
                key.style.height = whiteKeyHeight + 'px';
                key.style.fontSize = Math.max(6, Math.floor(whiteKeyWidth * 0.5)) + 'px';
                
                keyboardContainer.appendChild(key);
                this.pianoKeys[note] = key;
                whiteKeyCount++;
            }
        }
        
        // é»’éµã‚’é…ç½®ï¼ˆç™½éµã®ä¸Šã«é‡ã­ã‚‹ï¼‰
        for (let note = startNote; note <= endNote; note++) {
            const noteIndex = note % 12;
            
            if (blackKeyPattern.includes(noteIndex)) {
                const key = document.createElement('div');
                key.className = 'piano-key black';
                key.dataset.note = note;
                
                // é»’éµã«ã¯éŸ³åã‚’è¡¨ç¤ºã—ãªã„
                
                // é»’éµã®ä½ç½®ã‚’æ­£ç¢ºã«è¨ˆç®—
                // ã“ã®éŸ³ç¬¦ã‚ˆã‚Šå‰ã«ã‚ã‚‹ç™½éµã®æ•°ã‚’æ•°ãˆã‚‹
                let whiteKeysBeforeThisNote = 0;
                for (let prevNote = startNote; prevNote < note; prevNote++) {
                    const prevNoteIndex = prevNote % 12;
                    if (whiteKeyPattern.includes(prevNoteIndex)) {
                        whiteKeysBeforeThisNote++;
                    }
                }
                
                // é»’éµã®ä½ç½®ã‚’ç™½éµã®å¢ƒç•Œã«é…ç½®
                // é»’éµã¯å¯¾å¿œã™ã‚‹ç™½éµã®å³ç«¯ã«é…ç½®ã•ã‚Œã‚‹
                let leftPosition = 0;
                if (noteIndex === 1) { // C#: Cã¨Dã®é–“
                    leftPosition = whiteKeysBeforeThisNote * whiteKeyWidth - (blackKeyWidth / 2);
                } else if (noteIndex === 3) { // D#: Dã¨Eã®é–“  
                    leftPosition = whiteKeysBeforeThisNote * whiteKeyWidth - (blackKeyWidth / 2);
                } else if (noteIndex === 6) { // F#: Fã¨Gã®é–“
                    leftPosition = whiteKeysBeforeThisNote * whiteKeyWidth - (blackKeyWidth / 2);
                } else if (noteIndex === 8) { // G#: Gã¨Aã®é–“
                    leftPosition = whiteKeysBeforeThisNote * whiteKeyWidth - (blackKeyWidth / 2);
                } else if (noteIndex === 10) { // A#: Aã¨Bã®é–“
                    leftPosition = whiteKeysBeforeThisNote * whiteKeyWidth - (blackKeyWidth / 2);
                }
                
                key.style.left = leftPosition + 'px';
                key.style.top = '0px';
                key.style.width = blackKeyWidth + 'px';
                key.style.height = blackKeyHeight + 'px';
                key.style.fontSize = Math.max(5, Math.floor(blackKeyWidth * 0.4)) + 'px';
                
                keyboardContainer.appendChild(key);
                this.pianoKeys[note] = key;
            }
        }
        
        console.log(`Piano keyboard created with ${Object.keys(this.pianoKeys).length} keys`);
        console.log(`Container width: ${container.offsetWidth}, Available width: ${availableWidth}, White key width: ${whiteKeyWidth}`);
        console.log(`Total keyboard width: ${totalKeyboardWidth}, Will overflow: ${totalKeyboardWidth > availableWidth}`);
    }
    
    async setupMIDI() {
        if (!navigator.requestMIDIAccess) {
            this.updateMIDIStatus('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯Web MIDI APIã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚Chrome/Edgeã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚', false);
            return;
        }

        try {
            console.log('MIDI access ã‚’è¦æ±‚ä¸­...');
            this.midiAccess = await navigator.requestMIDIAccess();
            console.log('MIDI access æˆåŠŸ');
            this.midiAccess.addEventListener('statechange', () => {
                console.log('MIDI statechange event triggered');
                this.refreshMIDIDevices();
            });
            this.refreshMIDIDevices();
        } catch (error) {
            console.error('MIDI access failed:', error);
            let errorMessage = 'MIDIã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ: ';
            if (error.name === 'SecurityError') {
                errorMessage += 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¨ãƒ©ãƒ¼ã€‚HTTPSã¾ãŸã¯localhostã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„ã€‚';
            } else {
                errorMessage += error.message;
            }
            this.updateMIDIStatus(errorMessage, false);
        }
    }
    
    refreshMIDIDevices() {
        if (!this.midiAccess) return;
        
        const inputs = Array.from(this.midiAccess.inputs.values());
        console.log(`=== refreshMIDIDevices called ===`);
        console.log(`ç™ºè¦‹ã•ã‚ŒãŸMIDIãƒ‡ãƒã‚¤ã‚¹æ•°: ${inputs.length}`);
        
        // ç¾åœ¨ã®é¸æŠã‚’ä¿å­˜
        const currentSelection = this.elements.midiDevicesSelect.value;
        console.log(`ç¾åœ¨ã®é¸æŠ: "${currentSelection}"`);
        
        // ãƒ‡ãƒã‚¤ã‚¹ãƒªã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢
        this.elements.midiDevicesSelect.innerHTML = '<option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„</option>';
        
        if (inputs.length > 0) {
            this.elements.midiDeviceSelection.style.display = 'flex';
            
            inputs.forEach((input, index) => {
                console.log(`ãƒ‡ãƒã‚¤ã‚¹ ${index + 1}: ${input.name} (ID: ${input.id})`);
                const option = document.createElement('option');
                option.value = input.id;
                option.textContent = `${input.name || 'Unknown Device'} (${input.manufacturer || 'Unknown'})`;
                this.elements.midiDevicesSelect.appendChild(option);
            });
            
            // é¸æŠã‚’å¾©å…ƒï¼ˆãƒ‡ãƒã‚¤ã‚¹ãŒã¾ã å­˜åœ¨ã™ã‚‹å ´åˆï¼‰
            if (currentSelection && this.midiAccess.inputs.get(currentSelection)) {
                this.elements.midiDevicesSelect.value = currentSelection;
                console.log(`é¸æŠã‚’å¾©å…ƒ: "${currentSelection}"`);
                // æ—¢ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°
                if (this.midiInput && this.midiInput.id === currentSelection) {
                    this.updateMIDIStatus(`${this.midiInput.name} ã«æ¥ç¶šã•ã‚Œã¾ã—ãŸ`, true);
                } else {
                    this.updateMIDIStatus(`${inputs.length}å€‹ã®MIDIãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚`, false);
                }
            } else {
                this.updateMIDIStatus(`${inputs.length}å€‹ã®MIDIãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚`, false);
            }
        } else {
            this.elements.midiDeviceSelection.style.display = 'none';
            this.updateMIDIStatus('MIDIãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚USB-MIDIãƒ‡ãƒã‚¤ã‚¹ã‚’æ¥ç¶šã—ã¦ãã ã•ã„ã€‚', false);
        }
        
        this.updateGameButtonVisibility();
    }
    
    connectToSelectedDevice() {
        const selectedDeviceId = this.elements.midiDevicesSelect.value;
        console.log(`=== ãƒ‡ãƒã‚¤ã‚¹é¸æŠé–‹å§‹: "${selectedDeviceId}" ===`);
        console.log(`Select element value: "${this.elements.midiDevicesSelect.value}"`);
        console.log(`Select element selectedIndex: ${this.elements.midiDevicesSelect.selectedIndex}`);
        
        if (!selectedDeviceId || selectedDeviceId === "") {
            console.log('ãƒ‡ãƒã‚¤ã‚¹ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ - å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—');
            this.updateMIDIStatus('ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„', false);
            this.updateGameButtonVisibility();
            return;
        }
        
        // æ—¢å­˜ã®æ¥ç¶šã‚’åˆ‡æ–­
        this.disconnectMIDI();
        
        // æ–°ã—ã„ãƒ‡ãƒã‚¤ã‚¹ã«æ¥ç¶š
        const selectedInput = this.midiAccess.inputs.get(selectedDeviceId);
        if (selectedInput) {
            console.log(`ãƒ‡ãƒã‚¤ã‚¹ã«æ¥ç¶šä¸­: ${selectedInput.name}`);
            this.midiInput = selectedInput;
            this.midiInput.addEventListener('midimessage', this.midiMessageHandler);
            this.updateMIDIStatus(`${this.midiInput.name} ã«æ¥ç¶šã•ã‚Œã¾ã—ãŸ`, true);
            
            // è¨­å®šã‚’ä¿å­˜
            this.settings.selectedMidiDevice = selectedDeviceId;
            this.saveSettings();
            
            console.log(`=== ãƒ‡ãƒã‚¤ã‚¹æ¥ç¶šå®Œäº†: ${this.midiInput.name} ===`);
        } else {
            console.error(`ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${selectedDeviceId}`);
            this.updateMIDIStatus('é¸æŠã•ã‚ŒãŸãƒ‡ãƒã‚¤ã‚¹ã«æ¥ç¶šã§ãã¾ã›ã‚“ã§ã—ãŸ', false);
        }
        
        this.updateGameButtonVisibility();
    }
    
    disconnectMIDI() {
        if (this.midiInput) {
            console.log(`MIDIåˆ‡æ–­: ${this.midiInput.name}`);
            try {
                this.midiInput.removeEventListener('midimessage', this.midiMessageHandler);
            } catch (e) {
                console.warn('ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼å‰Šé™¤ã§ã‚¨ãƒ©ãƒ¼:', e);
            }
            this.midiInput = null;
        }
        
        // æŠ¼ä¸‹çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
        this.pressedKeys.clear();
        this.clearPianoKeyDisplay();
    }
    
    onMIDIMessage(event) {
        const [command, note, velocity] = event.data;
        console.log(`MIDI: cmd=${command}, note=${note}, vel=${velocity}`);
        
        // Control Change (CC) ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
        if (command === 176) {
            if (note === 64) {
                // ã‚µã‚¹ãƒ†ã‚£ãƒ¼ãƒ³ãƒšãƒ€ãƒ« (CC#64)
                this.handleSustainPedal(velocity >= 64);
                return;
            }
        }
        
        if (command === 144 && velocity > 0) {
            // Note ON
            this.pressedKeys.add(note);
            this.updatePianoKeyDisplay(note, true);
            this.playNote(note, velocity);
        } else if (command === 128 || (command === 144 && velocity === 0)) {
            // Note OFF
            this.pressedKeys.delete(note);
            this.handleNoteOff(note);
        }
        
        if (this.gameActive) {
            this.checkChord();
        }
    }
    
    handleSustainPedal(pressed) {
        console.log(`Sustain pedal: ${pressed ? 'ON' : 'OFF'}`);
        this.sustainPedalPressed = pressed;
        
        // UIã®æ›´æ–°
        if (this.elements.pedalState) {
            this.elements.pedalState.textContent = pressed ? 'ON' : 'OFF';
            this.elements.pedalState.className = 'pedal-state ' + (pressed ? 'on' : 'off');
        }
        
        if (!pressed) {
            // ã‚µã‚¹ãƒ†ã‚£ãƒ¼ãƒ³ãƒšãƒ€ãƒ«ã‚’é›¢ã—ãŸæ™‚ã€ç¶­æŒã•ã‚Œã¦ã„ãŸéŸ³ã‚’åœæ­¢
            for (const note of this.sustainedNotes) {
                if (!this.pressedKeys.has(note)) {
                    this.stopNote(note);
                    // è¦–è¦šçš„è¡¨ç¤ºã‚‚ç¢ºå®Ÿã«ã‚¯ãƒªã‚¢ï¼ˆæ—¢ã«ã‚¯ãƒªã‚¢ã•ã‚Œã¦ã„ã‚‹ã¯ãšã ãŒå¿µã®ãŸã‚ï¼‰
                    this.updatePianoKeyDisplay(note, false);
                }
            }
            this.sustainedNotes.clear();
        }
    }
    
    handleNoteOff(note) {
        // éµç›¤ã®è¦–è¦šçš„ãªæŠ¼ä¸‹çŠ¶æ…‹ã¯å¸¸ã«è§£é™¤
        this.updatePianoKeyDisplay(note, false);
        
        if (this.sustainPedalPressed) {
            // ã‚µã‚¹ãƒ†ã‚£ãƒ¼ãƒ³ãƒšãƒ€ãƒ«ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹å ´åˆã€éŸ³ã®ã¿ç¶­æŒ
            this.sustainedNotes.add(note);
            console.log(`Note ${note} sustained by pedal (visual released)`);
        } else {
            // é€šå¸¸ã®ãƒãƒ¼ãƒˆã‚ªãƒ•å‡¦ç†ï¼ˆéŸ³ã‚‚åœæ­¢ï¼‰
            this.stopNote(note);
        }
    }
    
    updatePianoKeyDisplay(note, pressed) {
        console.log(`Updating piano key ${note}, pressed: ${pressed}`);
        const key = this.pianoKeys[note];
        if (key) {
            if (pressed) {
                key.classList.add('pressed');
                console.log(`Key ${note} marked as pressed`);
            } else {
                key.classList.remove('pressed');
                console.log(`Key ${note} unmarked as pressed`);
            }
        } else {
            console.log(`Key ${note} not found in piano display`);
        }
    }
    
    clearPianoKeyDisplay() {
        // å…¨ã¦ã®éµç›¤ã‹ã‚‰æŠ¼ä¸‹çŠ¶æ…‹ã‚’å‰Šé™¤
        Object.values(this.pianoKeys).forEach(key => {
            key.classList.remove('pressed');
        });
        console.log('å…¨ã¦ã®éµç›¤ã®æŠ¼ä¸‹çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢');
    }
    
    updateMIDIStatus(message, connected) {
        this.elements.midiMessage.textContent = message;
        this.elements.midiStatus.className = connected ? 'midi-status connected' : 'midi-status';
        
        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚‚æ›´æ–°
        if (this.elements.statusIndicator) {
            this.elements.statusIndicator.textContent = connected ? 'ğŸŸ¢' : 'ğŸ”´';
        }
    }
    
    // è¨­å®šç®¡ç†ãƒ¡ã‚½ãƒƒãƒ‰
    loadSettings() {
        const defaultSettings = {
            volume: 100,
            selectedMidiDevice: null
        };
        
        try {
            const savedSettings = localStorage.getItem('chordPracticeSettings');
            if (savedSettings) {
                return { ...defaultSettings, ...JSON.parse(savedSettings) };
            }
        } catch (error) {
            console.warn('Failed to load settings:', error);
        }
        
        return defaultSettings;
    }
    
    saveSettings() {
        try {
            localStorage.setItem('chordPracticeSettings', JSON.stringify(this.settings));
            console.log('Settings saved:', this.settings);
        } catch (error) {
            console.warn('Failed to save settings:', error);
        }
    }
    
    applySettings() {
        // éŸ³é‡è¨­å®šã®é©ç”¨
        if (this.elements.volumeSlider && this.elements.volumeValue) {
            this.elements.volumeSlider.value = this.settings.volume;
            this.elements.volumeValue.textContent = `${this.settings.volume}%`;
            this.updateVolume(this.settings.volume);
        }
        
        // MIDIãƒ‡ãƒã‚¤ã‚¹è¨­å®šã®é©ç”¨ï¼ˆMIDIã‚¢ã‚¯ã‚»ã‚¹ç¢ºç«‹å¾Œã«é©ç”¨ï¼‰
        if (this.settings.selectedMidiDevice) {
            setTimeout(() => this.applyMidiDeviceSelection(), 1000);
        }
    }
    
    applyMidiDeviceSelection() {
        if (this.elements.midiDevicesSelect && this.settings.selectedMidiDevice) {
            // ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒã‚¤ã‚¹ãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
            const options = Array.from(this.elements.midiDevicesSelect.options);
            const targetOption = options.find(option => option.value === this.settings.selectedMidiDevice);
            
            if (targetOption) {
                this.elements.midiDevicesSelect.value = this.settings.selectedMidiDevice;
                this.connectToSelectedDevice();
                console.log('Applied saved MIDI device:', this.settings.selectedMidiDevice);
            } else {
                console.log('Saved MIDI device no longer available:', this.settings.selectedMidiDevice);
                this.settings.selectedMidiDevice = null;
                this.saveSettings();
            }
        }
    }
    
    updateGameButtonVisibility() {
        // MIDIãƒ‡ãƒã‚¤ã‚¹ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ã€Œã‚²ãƒ¼ãƒ ç”»é¢ã¸ã€ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
        if (this.midiInput) {
            this.elements.goToGameBtn.style.display = 'inline-block';
        } else {
            this.elements.goToGameBtn.style.display = 'none';
        }
    }
    
    updateVolume(value) {
        const volume = value / 100;
        if (this.masterVolume) {
            this.masterVolume.gain.setValueAtTime(volume * 3, this.audioContext.currentTime);
        }
        if (this.elements.volumeValue) {
            this.elements.volumeValue.textContent = `${value}%`;
        }
        
        // è¨­å®šã‚’ä¿å­˜
        this.settings.volume = parseInt(value);
        this.saveSettings();
        
        console.log(`Volume updated to ${value}% (${(volume * 3).toFixed(2)}x) with limiter protection`);
    }
    
    noteToString(midiNote) {
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const octave = Math.floor(midiNote / 12) - 1;
        const noteName = noteNames[midiNote % 12];
        return `${noteName}${octave}`;
    }
    
    setupEventListeners() {
        this.elements.startBtn.addEventListener('click', () => this.startGame());
        this.elements.restartBtn.addEventListener('click', () => this.restartGame());
        this.elements.midiDevicesSelect.addEventListener('change', (event) => {
            console.log(`Change event triggered, target value: "${event.target.value}"`);
            // å°‘ã—é…å»¶ã•ã›ã¦ã€DOMæ›´æ–°ã®ç«¶åˆã‚’é¿ã‘ã‚‹
            setTimeout(() => {
                this.connectToSelectedDevice();
            }, 10);
        });
        
        // ç”»é¢é·ç§»ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        this.elements.gameStartBtn.addEventListener('click', async () => await this.showGameScreen());
        this.elements.settingsBtn.addEventListener('click', () => this.showSettingsScreen());
        this.elements.backToTitleBtn.addEventListener('click', () => this.showTitleScreen());
        this.elements.backToTitleFromGameBtn.addEventListener('click', () => this.showTitleScreen());
        this.elements.goToGameBtn.addEventListener('click', async () => await this.showGameScreen());
        
        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        window.addEventListener('resize', () => this.handleWindowResize());
        
        // éŸ³é‡ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        if (this.elements.volumeSlider) {
            this.elements.volumeSlider.addEventListener('input', (event) => this.updateVolume(event.target.value));
        }
        
        // ã‚µã‚¹ãƒ†ã‚£ãƒ¼ãƒ³ãƒšãƒ€ãƒ«ã®åˆæœŸçŠ¶æ…‹è¨­å®š
        if (this.elements.pedalState) {
            this.elements.pedalState.textContent = 'OFF';
            this.elements.pedalState.className = 'pedal-state off';
        }
        
        // ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã®è¨­å®š
        if (this.elements.versionInfo) {
            this.elements.versionInfo.textContent = `v${ChordPracticeApp.VERSION}`;
        }
    }
    
    handleWindowResize() {
        // ã‚²ãƒ¼ãƒ ç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿éµç›¤ã‚’å†ä½œæˆ
        if (this.elements.gameScreen.style.display === 'block') {
            // å°‘ã—é…å»¶ã•ã›ã¦ã€ãƒªã‚µã‚¤ã‚ºãŒå®Œäº†ã—ã¦ã‹ã‚‰å†è¨ˆç®—
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => {
                this.createPianoKeyboard();
                this.updateRangeDisplay();
            }, 100);
        }
    }
    
    showTitleScreen() {
        this.elements.titleScreen.style.display = 'block';
        this.elements.settingsScreen.style.display = 'none';
        this.elements.gameScreen.style.display = 'none';
        
        // ã‚²ãƒ¼ãƒ ã‚’åœæ­¢
        if (this.gameActive) {
            this.stopGame();
        }
    }
    
    showSettingsScreen() {
        this.elements.titleScreen.style.display = 'none';
        this.elements.settingsScreen.style.display = 'block';
        this.elements.gameScreen.style.display = 'none';
        this.updateGameButtonVisibility();
    }
    
    async showGameScreen() {
        // MIDIãƒ‡ãƒã‚¤ã‚¹ãŒå®Ÿéš›ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«æƒ…å ±ãŒã‚ã£ã¦ã‚‚ã€å®Ÿéš›ã®ãƒ‡ãƒã‚¤ã‚¹æ¥ç¶šã‚’ç¢ºèª
        let hasConnectedDevice = false;
        if (this.midiAccess) {
            const inputs = Array.from(this.midiAccess.inputs.values());
            hasConnectedDevice = inputs.some(input => input.connection === 'open' || input.state === 'connected');
        }
        
        if (!hasConnectedDevice) {
            // å®Ÿéš›ã«MIDIãƒ‡ãƒã‚¤ã‚¹ãŒæ¥ç¶šã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ç’°å¢ƒè¨­å®šç”»é¢ã«é·ç§»
            this.showSettingsScreen();
            this.updateMIDIStatus('ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã™ã‚‹ã«ã¯MIDIãƒ‡ãƒã‚¤ã‚¹ã‚’æ¥ç¶šã—ã¦ãã ã•ã„', false);
            return;
        }
        
        this.elements.titleScreen.style.display = 'none';
        this.elements.settingsScreen.style.display = 'none';
        this.elements.gameScreen.style.display = 'block';
        
        // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãŒæœªåˆæœŸåŒ–ã®å ´åˆã¯åˆæœŸåŒ–ã‚’å®Ÿè¡Œï¼ˆåˆå›ã‚²ãƒ¼ãƒ ç”»é¢é·ç§»æ™‚ï¼‰
        if (!this.audioContext || !this.audioBuffers || this.audioBuffers.size === 0) {
            const success = await this.initializeAudioForGame();
            if (!success) {
                // åˆæœŸåŒ–å¤±æ•—æ™‚ã¯ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã«æˆ»ã‚‹
                this.showTitleScreen();
                return;
            }
        }
        
        // ã‚²ãƒ¼ãƒ UIã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
        this.resetGameUI();
        
        // ã‚²ãƒ¼ãƒ ç”»é¢ã«ç§»è¡Œæ™‚ã«éµç›¤ã‚’å†ä½œæˆã—ã¦ç¯„å›²ã‚’è¡¨ç¤º
        setTimeout(() => {
            this.createPianoKeyboard();
            this.generateRandomRange();
        }, 100);
    }
    
    resetGameUI() {
        // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
        this.gameActive = false;
        this.waitingForNextQuestion = false;
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
        }
        
        // æŒ‡ç¤ºæ–‡ã‚’éè¡¨ç¤º
        if (this.elements.chordInstruction) {
            this.elements.chordInstruction.style.display = 'none';
        }
        
        // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã‚’ã‚¯ãƒªã‚¢
        if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
            this.countdownInterval = null;
        }
        
        // ã‚¹ã‚³ã‚¢ã¨ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
        this.score = 0;
        this.timeLeft = 60;
        this.elements.score.textContent = this.score;
        this.elements.timer.textContent = this.timeLeft;
        
        // ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
        this.elements.startBtn.style.display = 'inline-block';
        this.elements.restartBtn.style.display = 'none';
        
        // UIã®è¡¨ç¤ºçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
        this.elements.resultDisplay.style.display = 'none';
        this.elements.chordDisplay.style.display = 'block';
        this.elements.currentChord.textContent = 'ã‚¹ã‚¿ãƒ¼ãƒˆã‚’æŠ¼ã—ã¦ãã ã•ã„';
        this.elements.currentChord.style.opacity = '1';
        this.elements.countdownDisplay.style.display = 'none';
        this.elements.correctIndicator.style.display = 'none';
        
        // çµæœã‚¨ãƒªã‚¢ã‚‚éè¡¨ç¤ºã«ã™ã‚‹
        this.elements.resultArea.style.display = 'none';
    }
    
    async startGame() {
        this.elements.startBtn.style.display = 'none';
        this.elements.restartBtn.style.display = 'inline-block';
        this.elements.resultArea.style.display = 'none';
        
        // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³çµæœè¡¨ç¤ºã‚’éš ã—ã¦å’ŒéŸ³è¡¨ç¤ºã‚’è¡¨ç¤º
        this.elements.resultDisplay.style.display = 'none';
        this.elements.chordDisplay.style.display = 'block';
        
        // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³é–‹å§‹
        await this.startCountdown();
        
        // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³å¾Œã«ã‚²ãƒ¼ãƒ é–‹å§‹
        this.gameActive = true;
        this.score = 0;
        this.timeLeft = 60;
        
        // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«æŒ‡ç¤ºæ–‡ã‚’è¡¨ç¤º
        if (this.elements.chordInstruction) {
            this.elements.chordInstruction.style.display = 'block';
        }
        
        this.generateRandomRange();
        this.nextChord();
        this.startTimer();
    }
    
    async startCountdown() {
        return new Promise((resolve) => {
            let countdown = 3;
            this.elements.countdownDisplay.style.display = 'flex';
            this.elements.currentChord.style.opacity = '0.3';
            
            // æœ€åˆã®æ•°å­—ã‚’å³åº§ã«è¡¨ç¤º
            this.elements.countdownNumber.textContent = countdown;
            this.elements.countdownNumber.style.animation = 'countdownPulse 1s ease-in-out';
            
            this.countdownInterval = setInterval(() => {
                countdown--;
                
                if (countdown > 0) {
                    this.elements.countdownNumber.textContent = countdown;
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å¼·åˆ¶çš„ã«ãƒªã‚»ãƒƒãƒˆ
                    this.elements.countdownNumber.style.animation = 'none';
                    this.elements.countdownNumber.offsetHeight; // å¼·åˆ¶ãƒªãƒ•ãƒ­ãƒ¼
                    this.elements.countdownNumber.style.animation = 'countdownPulse 1s ease-in-out';
                } else {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                    this.elements.countdownDisplay.style.display = 'none';
                    this.elements.currentChord.style.opacity = '1';
                    resolve();
                }
            }, 1000);
        });
    }
    
    restartGame() {
        this.stopGame();
        this.startGame();
    }
    
    stopGame() {
        this.gameActive = false;
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
        }
        
        this.elements.startBtn.style.display = 'inline-block';
        this.elements.restartBtn.style.display = 'none';
        
        // æŒ‡ç¤ºæ–‡ã‚’éè¡¨ç¤º
        if (this.elements.chordInstruction) {
            this.elements.chordInstruction.style.display = 'none';
        }
        
        // å’ŒéŸ³è¡¨ç¤ºã‚’éš ã—ã¦ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³çµæœè¡¨ç¤ºã‚’è¡¨ç¤º
        this.elements.chordDisplay.style.display = 'none';
        this.elements.resultDisplay.style.display = 'block';
        this.elements.finalScoreInline.textContent = this.score;
        
        // çµæœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¨­å®š
        let message = 'ãŠç–²ã‚Œã•ã¾ã§ã—ãŸï¼';
        if (this.score >= 15) {
            message = 'ç´ æ™´ã‚‰ã—ã„ï¼å®Œç’§ãªæ¼”å¥ã§ã™ï¼';
        } else if (this.score >= 10) {
            message = 'ã¨ã¦ã‚‚è‰¯ã„æ¼”å¥ã§ã—ãŸï¼';
        } else if (this.score >= 5) {
            message = 'è‰¯ã„èª¿å­ã§ã™ï¼';
        }
        this.elements.resultMessageInline.textContent = message;
    }
    
    startTimer() {
        this.updateTimer();
        this.timer = setInterval(() => {
            this.timeLeft--;
            this.updateTimer();
            
            if (this.timeLeft <= 0) {
                this.stopGame();
            }
        }, 1000);
    }
    
    updateTimer() {
        this.elements.timer.textContent = this.timeLeft;
    }
    
    generateRandomRange() {
        // å›ºå®šç¯„å›²: å·¦æ‰‹C2-C3ã€å³æ‰‹C4-C5
        this.currentRange = {
            leftHandMin: 36,  // C2
            leftHandMax: 48,  // C3
            rightHandMin: 60, // C4
            rightHandMax: 72  // C5
        };
        
        this.updateRangeDisplay();
    }
    
    updateRangeDisplay() {
        // å‰ã®ç¯„å›²è¡¨ç¤ºã‚’ã‚¯ãƒªã‚¢
        Object.values(this.pianoKeys).forEach(key => {
            key.classList.remove('left-hand-range', 'right-hand-range');
        });
        
        if (!this.currentRange) return;
        
        // å·¦æ‰‹ç¯„å›²ã‚’é’è‰²ã§è¡¨ç¤ºï¼ˆç™½éµã®ã¿ï¼‰
        for (let note = this.currentRange.leftHandMin; note <= this.currentRange.leftHandMax; note++) {
            const key = this.pianoKeys[note];
            if (key && key.classList.contains('white')) {
                key.classList.add('left-hand-range');
            }
        }
        
        // å³æ‰‹ç¯„å›²ã‚’ç·‘è‰²ã§è¡¨ç¤ºï¼ˆç™½éµã®ã¿ï¼‰
        for (let note = this.currentRange.rightHandMin; note <= this.currentRange.rightHandMax; note++) {
            const key = this.pianoKeys[note];
            if (key && key.classList.contains('white')) {
                key.classList.add('right-hand-range');
            }
        }
    }
    
    nextChord() {
        // é€£ç¶šã—ã¦åŒã˜ã‚³ãƒ¼ãƒ‰ãŒå‡ºé¡Œã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹
        let newChord;
        do {
            newChord = this.chords[Math.floor(Math.random() * this.chords.length)];
        } while (this.currentChord && newChord.name === this.currentChord.name && this.chords.length > 1);
        
        this.currentChord = newChord;
        this.elements.currentChord.textContent = this.currentChord.name;
        
        // Reset waiting state to allow new answers
        this.waitingForNextQuestion = false;
        
        // ã‚³ãƒ¼ãƒ‰è¡¨ç¤ºã®è‰²ã‚’é€šå¸¸ã«æˆ»ã™
        this.elements.currentChord.style.color = '#2d3748';
        
        // æ­£è§£ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆé€£ç¶šæ­£è§£é˜²æ­¢ï¼‰
        this.justAnswered = true;
        setTimeout(() => {
            this.justAnswered = false;
        }, 200);
    }
    
    checkChord() {
        if (this.pressedKeys.size === 0 || this.justAnswered || this.waitingForNextQuestion) return;
        
        const pressedNotes = Array.from(this.pressedKeys);
        const leftHandNotes = pressedNotes.filter(note => 
            note >= this.currentRange.leftHandMin && note <= this.currentRange.leftHandMax
        );
        const rightHandNotes = pressedNotes.filter(note => 
            note >= this.currentRange.rightHandMin && note <= this.currentRange.rightHandMax
        );
        
        if (leftHandNotes.length === 0 || rightHandNotes.length === 0) return;
        
        const leftHandNote = leftHandNotes[0] % 12;
        const rightHandNotesMod = rightHandNotes.map(note => note % 12);
        
        const chordRoot = this.currentChord.notes[0];
        const chordNotes = new Set(this.currentChord.notes);
        
        if (leftHandNote === chordRoot && 
            rightHandNotesMod.length === 3 && 
            rightHandNotesMod.every(note => chordNotes.has(note)) &&
            new Set(rightHandNotesMod).size === 3) {
            
            this.correctAnswer();
        }
    }
    
    async playCorrectAnswerSound() {
        try {
            console.log('playCorrectAnswerSoundé–‹å§‹');
            
            // æ­£è§£éŸ³å°‚ç”¨ã®MP3ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨
            const correctSoundPath = 'mp3/correct001.mp3';
            console.log('æ­£è§£éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹:', correctSoundPath);
            
            // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®çŠ¶æ…‹ã‚’ç¢ºèª
            if (!this.audioContext) {
                console.error('ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            if (this.audioContext.state === 'suspended') {
                console.log('ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å†é–‹ã—ã¾ã™');
                await this.audioContext.resume();
            }
            
            // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒƒãƒ•ã‚¡ãŒæ—¢ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (!this.audioBuffers.has(correctSoundPath)) {
                console.log('æ­£è§£éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™');
                await this.loadSingleAudioFile(correctSoundPath);
            }
            
            const buffer = this.audioBuffers.get(correctSoundPath);
            if (buffer) {
                console.log('æ­£è§£éŸ³ã‚’å†ç”Ÿé–‹å§‹');
                const source = this.audioContext.createBufferSource();
                const gainNode = this.audioContext.createGain();
                gainNode.gain.setValueAtTime(0.06, this.audioContext.currentTime); // éŸ³é‡ã‚’6%ã«
                
                source.buffer = buffer;
                source.connect(gainNode);
                gainNode.connect(this.masterVolume);
                source.start();
                
                console.log('æ­£è§£éŸ³ã‚’å†ç”Ÿã—ã¾ã—ãŸ');
            } else {
                console.error('æ­£è§£éŸ³ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒƒãƒ•ã‚¡ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            }
        } catch (error) {
            console.error('æ­£è§£éŸ³ã®å†ç”Ÿã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
        }
    }
    
    async correctAnswer() {
        this.score++;
        this.elements.score.textContent = this.score;
        
        // Set waiting state to prevent incorrect answers during delay
        this.waitingForNextQuestion = true;
        
        // å¾…æ©Ÿä¸­ã¯ã‚³ãƒ¼ãƒ‰è¡¨ç¤ºã‚’ç°è‰²ã«ã™ã‚‹
        this.elements.currentChord.style.color = '#a0aec0';
        
        console.log('æ­£è§£ï¼æ­£è§£éŸ³ã‚’å†ç”Ÿã—ã¾ã™');
        
        // æ­£è§£éŸ³ã‚’è‡ªå‹•æ¼”å¥
        try {
            await this.playCorrectAnswerSound();
        } catch (error) {
            console.error('æ­£è§£éŸ³ã®å†ç”Ÿã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ:', error);
        }
        
        this.elements.chordDisplay.classList.add('correct');
        
        // æ­£è§£ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’è¡¨ç¤º
        this.elements.correctIndicator.style.display = 'flex';
        
        // 1ç§’å¾Œã«æ¬¡ã®å•é¡Œã«ç§»è¡Œ
        setTimeout(() => {
            this.elements.chordDisplay.classList.remove('correct');
            this.elements.correctIndicator.style.display = 'none';
            this.nextChord();
        }, 1000);
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new ChordPracticeApp();
});
    </script>
</body>
</html>